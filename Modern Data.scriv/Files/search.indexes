<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="28">
            <Title>modern_stream_type_definition_float64</Title>
            <Text>void
(*modern_stream_type_definition_float64)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="172">
            <Title>modern_node_get_int8_type</Title>
            <Text>modern *
modern_node_get_int8_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="34">
            <Title>modern_stream_type_definition_named_is_next</Title>
            <Text>void
(*modern_stream_type_definition_named_is_next)
(void *processor_state,
 void *stream_state,
 struct modern_hash *name);</Text>
        </Document>
        <Document ID="142">
            <Title>modern_node_get_utf8_data_piece</Title>
            <Text>uint8_t *
modern_node_get_utf8_data_piece
(struct modern_error_handler *error_handler,
 modern *value,
 size_t offset,
 size_t bytes);</Text>
        </Document>
        <Document ID="29">
            <Title>modern_stream_type_definition_float128</Title>
            <Text>void
(*modern_stream_type_definition_float128)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="40">
            <Title>modern_stream_int64</Title>
            <Text>void
(*modern_stream_int64)
(void *processor_state,
 void *stream_state,
 int64_t value);</Text>
        </Document>
        <Document ID="112">
            <Title>modern_get_from_context</Title>
            <Text>modern *
modern_get_from_context
(modern_context *context,
 struct modern_hash *hash);</Text>
        </Document>
        <Document ID="35">
            <Title>modern_stream_type_definition_universe</Title>
            <Text>void
(*modern_stream_type_definition_universe)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="173">
            <Title>Values</Title>
        </Document>
        <Document ID="41">
            <Title>modern_stream_nat8</Title>
            <Text>void
(*modern_stream_nat8)
(void *processor_state,
 void *stream_state,
 uint8_t value);</Text>
        </Document>
        <Document ID="143">
            <Title>modern_node_get_blob_bytes</Title>
            <Text>size_t
modern_node_get_blob_bytes
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="36">
            <Title>modern_stream_type</Title>
            <Text>void
(*modern_stream_type)
(void *processor_state,
 void *stream_state,
 struct modern_hash *type);</Text>
        </Document>
        <Document ID="113">
            <Title>Node-based deserialization</Title>
        </Document>
        <Document ID="42">
            <Title>modern_stream_float32</Title>
            <Text>void
(*modern_stream_float32)
(void *processor_state,
 void *stream_state,
 float value);</Text>
        </Document>
        <Document ID="37">
            <Title>modern_stream_int8</Title>
            <Text>void
(*modern_stream_int8)
(void *processor_state,
 void *stream_state,
 int8_t value);</Text>
        </Document>
        <Document ID="174">
            <Title>Values</Title>
        </Document>
        <Document ID="43">
            <Title>modern_stream_float64</Title>
            <Text>void
(*modern_stream_float64)
(void *processor_state,
 void *stream_state,
 double value);</Text>
        </Document>
        <Document ID="144">
            <Title>modern_node_get_blob_data_piece</Title>
            <Text>uint8_t *
modern_node_get_blob_data_piece
(struct modern_error_handler *error_handler,
 modern *value,
 size_t offset,
 size_t bytes);</Text>
        </Document>
        <Document ID="38">
            <Title>modern_stream_int16</Title>
            <Text>void
(*modern_stream_int16)
(void *processor_state,
 void *stream_state,
 int16_t value);</Text>
        </Document>
        <Document ID="114">
            <Title>modern_deserialize_memory</Title>
            <Text>modern *
modern_deserialize_memory
(modern_autorelease_pool *pool,
 modern_context *context,
 uint8_t *data,
 size_t length);</Text>
        </Document>
        <Document ID="240">
            <Title>modern_get_memory_allocating_vfile</Title>
            <Text>struct modern_vfile *
modern_get_memory_allocating_vfile
();</Text>
        </Document>
        <Document ID="210">
            <Title>modern_node_set_utf8</Title>
            <Text>void
modern_node_set_utf8
(struct modern_error_handler *error_handler,
 modern *node,
 uint8_t *data);</Text>
        </Document>
        <Document ID="44">
            <Title>modern_stream_float128</Title>
            <Text>void
(*modern_stream_float128)
(void *processor_state,
 void *stream_state,
 long double value);</Text>
        </Document>
        <Document ID="39">
            <Title>modern_stream_int32</Title>
            <Text>void
(*modern_stream_int32)
(void *processor_state,
 void *stream_state,
 int32_t value);</Text>
        </Document>
        <Document ID="175">
            <Title>modern_node_get_sigma_field</Title>
        </Document>
        <Document ID="145">
            <Title>Types</Title>
        </Document>
        <Document ID="45">
            <Title>modern_stream_utf8_start</Title>
            <Text>void
(*modern_stream_utf8_start)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="115">
            <Title>modern_deserialize_file</Title>
            <Text>modern *
modern_deserialize_file
(modern_autorelease_pool *pool,
 modern_context *context,
 FILE *file);</Text>
        </Document>
        <Document ID="241">
            <Title>modern_get_file_vfile</Title>
            <Text>struct modern_vfile *
modern_get_file_vfile
();</Text>
        </Document>
        <Document ID="50">
            <Title>modern_stream_blob_end</Title>
            <Text>void
(*modern_stream_blob_end)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="211">
            <Title>modern_node_set_blob</Title>
            <Text>void
modern_node_set_blob
(struct modern_error_handler *error_handler,
 modern *node,
 uint8_t *data,
 size_t bytes);</Text>
        </Document>
        <Document ID="46">
            <Title>modern_stream_utf8_data</Title>
            <Text>void
(*modern_stream_utf8_data)
(void *processor_state,
 void *stream_state,
 uint8_t *data,
 size_t length);</Text>
        </Document>
        <Document ID="176">
            <Title>modern_node_get_int16_type</Title>
            <Text>modern *
modern_node_get_int16_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="51">
            <Title>modern_stream_array_start</Title>
            <Text>void
(*modern_stream_array_start)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="146">
            <Title>modern_node_get_sigma_value</Title>
            <Text>modern *
modern_node_get_sigma_value
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="52">
            <Title>modern_stream_array_end</Title>
            <Text>void
(*modern_stream_array_end)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="47">
            <Title>modern_stream_utf8_end</Title>
            <Text>void
(*modern_stream_utf8_end)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="116">
            <Title>modern_deserialize_fd</Title>
            <Text>modern *
modern_deserialize_fd
(modern_autorelease_pool *pool,
 modern_context *context,
 int fd);</Text>
        </Document>
        <Document ID="242">
            <Title>modern_get_fd_vfile</Title>
            <Text>struct modern_vfile *
modern_get_fd_vfile
();</Text>
        </Document>
        <Document ID="53">
            <Title>modern_stream_union_field</Title>
            <Text>void
(*modern_stream_union_field)
(void *processor_state,
 void *stream_state,
 struct modern_hash *type,
 struct modern_hash *field);</Text>
        </Document>
        <Document ID="212">
            <Title>modern_node_set_array</Title>
            <Text>void
modern_node_set_array
(modern *node,
 uint64_t n_items,
 modern **values);</Text>
        </Document>
        <Document ID="48">
            <Title>modern_stream_blob_start</Title>
            <Text>void
(*modern_stream_blob_start)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="177">
            <Title>modern_node_get_int32_type</Title>
            <Text>modern *
modern_node_get_int32_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="147">
            <Title>modern_node_get_sigma_successor</Title>
            <Text>modern *
modern_node_get_sigma_successor
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="54">
            <Title>modern_stream_structure_start</Title>
            <Text>void
(*modern_stream_structure_start)
(void *processor_state,
 void *stream_state,
 struct modern_hash *type);</Text>
        </Document>
        <Document ID="117">
            <Title>modern_deserialize_vfile</Title>
            <Text>modern *
modern_deserialize_vfile
(modern_autorelease_pool *pool,
 modern_context *context,
 struct modern_vfile *vfile,
 void *vfile_state);</Text>
        </Document>
        <Document ID="49">
            <Title>modern_stream_blob_data</Title>
            <Text>void
(*modern_stream_blob_data)
(void *processor_state,
 void *stream_state,
 uint8_t *data,
 size_t length);</Text>
        </Document>
        <Document ID="60">
            <Title>modern_stream_type_index_is_next</Title>
            <Text>void
(*modern_stream_type_index_is_next)
(void *processor_state,
 void *stream_state,
 uint64_t index);</Text>
        </Document>
        <Document ID="213">
            <Title>modern_node_set_union</Title>
            <Text>void
modern_node_set_union
(modern *node,
 modern *type,
 struct modern_hash *field,
 modern *value);</Text>
        </Document>
        <Document ID="55">
            <Title>modern_stream_structure_field</Title>
            <Text>void
(*modern_stream_structure_field)
(void *processor_state,
 void *stream_state,
 struct modern_hash *field);</Text>
        </Document>
        <Document ID="243">
            <Title>Predefined Streams</Title>
        </Document>
        <Document ID="178">
            <Title>modern_node_get_int64_type</Title>
            <Text>modern *
modern_node_get_int64_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="61">
            <Title>modern_stream_type_family_is_next</Title>
            <Text>void
(*modern_stream_type_family_is_next)
(void *processor_state,
 void *stream_state,
 uint64_t n_items);</Text>
        </Document>
        <Document ID="148">
            <Title>modern_node_get_named_type_name</Title>
            <Text>struct modern_hash *
modern_node_get_named_type_name
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="56">
            <Title>modern_stream_structure_end</Title>
            <Text>void
(*modern_stream_structure_end)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="118">
            <Title>moden_deserialize_input_stream</Title>
            <Text>modern *
modern_deserialize_input_stream
(modern_autorelease_pool *pool,
 modern_context *context,
 void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="244">
            <Title>modern_get_explicatory_stream</Title>
            <Text>struct modern_stream *
modern_get_explicatory_stream
();</Text>
        </Document>
        <Document ID="62">
            <Title>modern_stream_end</Title>
            <Text>void
(*modern_stream_end)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="214">
            <Title>modern_node_set_structure</Title>
            <Text>void
modern_node_set_structure
(modern *node,
 modern *type,
 uint64_t n_items,
 struct modern_hash **fields,
 modern **values);</Text>
        </Document>
        <Document ID="179">
            <Title>modern_node_get_nat8_type</Title>
            <Text>modern *
modern_node_get_nat8_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="57">
            <Title>modern_stream_named_value_is_next</Title>
            <Text>void
(*modern_stream_named_value_is_next)
(void *processor_state,
 void *stream_state,
 struct modern_hash *name);</Text>
        </Document>
        <Document ID="149">
            <Title>modern_node_get_named_type_content_type</Title>
            <Text>modern *
modern_node_get_named_type_content_type
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="63">
            <Title>modern_stream_finalize</Title>
            <Text>void
(*modern_stream_finalize)
(void *stream_state);</Text>
        </Document>
        <Document ID="119">
            <Title>Node-based serialization</Title>
        </Document>
        <Document ID="58">
            <Title>modern_stream_lambda_is_next</Title>
            <Text>void
(*modern_stream_lambda_is_next)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="245">
            <Title>modern_get_documentation_stream</Title>
            <Text>struct modern_stream *
modern_get_documentation_stream
();
</Text>
        </Document>
        <Document ID="215">
            <Title>modern_node_set_named_value</Title>
            <Text>void
modern_node_set_named_value
(struct modern_error_handler *error_handler,
 modern *node,
 modern *type,
 modern *value);</Text>
        </Document>
        <Document ID="64">
            <Title>Virtual Files</Title>
            <Text>struct modern_vfile {
    …
};</Text>
        </Document>
        <Document ID="270">
            <Title>Error handlers</Title>
            <Text>struct modern_error_handler {
    …
};</Text>
        </Document>
        <Document ID="59">
            <Title>modern_stream_apply_is_next</Title>
            <Text>void
(*modern_stream_apply_is_next)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="70">
            <Title>int32_value_modern_node_type</Title>
            <Text>int32_value_modern_node_type = 3,</Text>
        </Document>
        <Document ID="271">
            <Title>modern_error_handler_memory</Title>
            <Text>void
(*modern_error_handler_memory)
(size_t requested_size);</Text>
        </Document>
        <Document ID="65">
            <Title>modern_vfile_read</Title>
            <Text>ssize_t
(*modern_vfile_read)
(void *vfile_state,
 uint8_t *buffer,
 size_t length);</Text>
        </Document>
        <Document ID="246">
            <Title>Types</Title>
        </Document>
        <Document ID="272">
            <Title>modern_error_handler_retain_count_overflow</Title>
            <Text>void
(*modern_error_handler_retain_count_overflow)
(void *retainable);</Text>
        </Document>
        <Document ID="71">
            <Title>int64_value_modern_node_type</Title>
            <Text>int64_value_modern_node_type = 4,</Text>
        </Document>
        <Document ID="216">
            <Title>Streaming Input </Title>
        </Document>
        <Document ID="66">
            <Title>modern_vfile_write</Title>
            <Text>ssize_t
(*modern_vfile_write)
(void *vfile_state,
 uint8_t *buffer,
 size_t length);</Text>
        </Document>
        <Document ID="273">
            <Title>modern_error_handler_retain_count_underflow</Title>
            <Text>void
(*modern_error_handler_retain_count_underflow)
(void *retainable);</Text>
        </Document>
        <Document ID="274">
            <Title>modern_error_handler_double_autorelease</Title>
            <Text>void
(*modern_error_handler_double_autorelease)
(void *retainable);</Text>
        </Document>
        <Document ID="72">
            <Title>nat8_value_modern_node_type</Title>
            <Text>nat8_value_modern_node_type = 5,</Text>
        </Document>
        <Document ID="275">
            <Title>modern_error_handler_type_mismatch</Title>
            <Text>void
(*modern_error_handler_type_mismatch)
(modern *expected,
 modern *actual);
</Text>
        </Document>
        <Document ID="67">
            <Title>Node Types</Title>
            <Text>enum modern_node_type {
    …
};</Text>
        </Document>
        <Document ID="247">
            <Title>Types are immutable</Title>
        </Document>
        <Document ID="217">
            <Title>modern_input_stream_memory</Title>
            <Text>void *
modern_input_stream_memory
(modern_autorelease_pool *pool,
 struct modern_stream *stream,
 uint8_t *data,
 size_t length);</Text>
        </Document>
        <Document ID="73">
            <Title>nat16_value_modern_node_type</Title>
            <Text>nat16_value_modern_node_type = 6,</Text>
        </Document>
        <Document ID="68">
            <Title>int8_value_modern_node_type</Title>
            <Text>int8_value_modern_node_type = 1,</Text>
        </Document>
        <Document ID="74">
            <Title>nat32_value_modern_node_type</Title>
            <Text>nat32_value_modern_node_type = 7,</Text>
        </Document>
        <Document ID="248">
            <Title>modern_allocator_alloc</Title>
            <Text>void *
(*modern_allocator_alloc)
(size_t size);</Text>
        </Document>
        <Document ID="69">
            <Title>int16_value_modern_node_type</Title>
            <Text>int16_value_modern_node_type = 2,</Text>
        </Document>
        <Document ID="80">
            <Title>blob_value_modern_node_type</Title>
            <Text>blob_value_modern_node_type = 13,</Text>
        </Document>
        <Document ID="218">
            <Title>modern_input_stream_file</Title>
            <Text>void *
modern_input_stream_file
(modern_autorelease_pool *pool,
 struct modern_stream *stream,
 FILE *file);</Text>
        </Document>
        <Document ID="75">
            <Title>nat64_value_modern_node_type</Title>
            <Text>nat64_value_modern_node_type = 8,</Text>
        </Document>
        <Document ID="81">
            <Title>sigma_value_modern_node_type</Title>
            <Text>sigma_value_modern_node_type = 14,</Text>
        </Document>
        <Document ID="76">
            <Title>float32_value_modern_node_type</Title>
            <Text>float32_value_modern_node_type = 9,</Text>
        </Document>
        <Document ID="249">
            <Title>modern_allocator_free</Title>
            <Text>void
(*modern_allocator_free)
(void *memory);</Text>
        </Document>
        <Document ID="219">
            <Title>modern_input_stream_fd</Title>
            <Text>void *
modern_input_stream_fd
(modern_autorelease_pool *pool,
 struct modern_stream *stream,
 int fd);</Text>
        </Document>
        <Document ID="82">
            <Title>named_value_modern_node_type</Title>
            <Text>named_value_modern_node_type = 15,</Text>
        </Document>
        <Document ID="77">
            <Title>float64_value_modern_node_type</Title>
            <Text>float64_value_modern_node_type = 10,</Text>
        </Document>
        <Document ID="83">
            <Title>int8_type_modern_node_type</Title>
            <Text>int8_type_modern_node_type = 16,</Text>
        </Document>
        <Document ID="78">
            <Title>float128_value_modern_node_type</Title>
            <Text>float128_value_modern_node_type = 11,</Text>
        </Document>
        <Document ID="84">
            <Title>int16_type_modern_node_type</Title>
            <Text>int16_type_modern_node_type = 17,</Text>
        </Document>
        <Document ID="79">
            <Title>utf8_value_modern_node_type</Title>
            <Text>utf8_value_modern_node_type = 12,</Text>
        </Document>
        <Document ID="90">
            <Title>nat64_type_modern_node_type</Title>
            <Text>nat64_type_modern_node_type = 23,</Text>
        </Document>
        <Document ID="85">
            <Title>int32_type_modern_node_type</Title>
            <Text>int32_type_modern_node_type = 18,</Text>
        </Document>
        <Document ID="91">
            <Title>float32_type_modern_node_type</Title>
            <Text>float32_type_modern_node_type = 24,</Text>
        </Document>
        <Document ID="86">
            <Title>int64_type_modern_node_type</Title>
            <Text>int64_type_modern_node_type = 19,</Text>
        </Document>
        <Document ID="92">
            <Title>float64_type_modern_node_type</Title>
            <Text>float64_type_modern_node_type = 25,</Text>
        </Document>
        <Document ID="87">
            <Title>nat8_type_modern_node_type</Title>
            <Text>nat8_type_modern_node_type = 20,</Text>
        </Document>
        <Document ID="93">
            <Title>float128_type_modern_node_type</Title>
            <Text>float128_type_modern_node_type = 26,</Text>
        </Document>
        <Document ID="88">
            <Title>nat16_type_modern_node_type</Title>
            <Text>nat16_type_modern_node_type = 21,</Text>
        </Document>
        <Document ID="94">
            <Title>utf8_type_modern_node_type</Title>
            <Text>utf8_type_modern_node_type = 27,</Text>
        </Document>
        <Document ID="89">
            <Title>nat32_type_modern_node_type</Title>
            <Text>nat32_type_modern_node_type = 22,</Text>
        </Document>
        <Document ID="95">
            <Title>blob_type_modern_node_type</Title>
            <Text>blob_type_modern_node_type = 28,</Text>
        </Document>
        <Document ID="96">
            <Title>sigma_type_modern_node_type</Title>
            <Text>sigma_type_modern_node_type = 29,</Text>
        </Document>
        <Document ID="97">
            <Title>named_type_modern_node_type</Title>
            <Text>named_type_modern_node_type = 30,</Text>
        </Document>
        <Document ID="98">
            <Title>universe_type_modern_node_type</Title>
            <Text>universe_type_modern_node_type = 31,</Text>
        </Document>
        <Document ID="99">
            <Title>lambda_modern_node_type</Title>
            <Text>lambda_modern_node_type = 32,</Text>
        </Document>
        <Document ID="190">
            <Title>modern_node_make_structure_type</Title>
            <Text>modern *
modern_node_make_structure_type
(uint64_t n_items,
 struct modern_hash **fields,
 modern **types);</Text>
        </Document>
        <Document ID="160">
            <Title>modern_node_make_nat32</Title>
            <Text>modern *
modern_node_make_nat32
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint32_t value);</Text>
        </Document>
        <Document ID="130">
            <Title>modern_node_get_int8</Title>
            <Text>int8_t
modern_node_get_int8
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="100">
            <Title>apply_modern_node_type</Title>
            <Text>apply_modern_node_type = 33,</Text>
        </Document>
        <Document ID="191">
            <Title>modern_node_make_named_type</Title>
            <Text>modern *
modern_node_make_named_type
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 struct modern_hash *name,
 modern *content_type);</Text>
        </Document>
        <Document ID="161">
            <Title>modern_node_make_nat64</Title>
            <Text>modern *
modern_node_make_nat64
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint64_t value);</Text>
        </Document>
        <Document ID="131">
            <Title>modern_node_get_int16</Title>
            <Text>int16_t
modern_node_get_int16
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="101">
            <Title>Memory management</Title>
        </Document>
        <Document ID="192">
            <Title>modern_node_get_universe_type</Title>
            <Text>modern *
modern_node_make_universe_type
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint64_t level);</Text>
        </Document>
        <Document ID="162">
            <Title>modern_node_make_float32</Title>
            <Text>modern *
modern_node_make_float32
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 float value);</Text>
        </Document>
        <Document ID="132">
            <Title>modern_node_get_int32</Title>
            <Text>int32_t
modern_node_get_int32
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="102">
            <Title>modern_make_autorelease_pool</Title>
            <Text>modern_autorelease_pool *
modern_make_autorelease_pool
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator);</Text>
        </Document>
        <Document ID="193">
            <Title>modern_node_make_lambda</Title>
            <Text>modern *
modern_node_make_lambda
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 modern *content);</Text>
        </Document>
        <Document ID="163">
            <Title>modern_node_make_float64</Title>
            <Text>modern *
modern_node_make_float64
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 double value);</Text>
        </Document>
        <Document ID="133">
            <Title>modern_node_get_int64</Title>
            <Text>int64_t
modern_node_get_int64
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="103">
            <Title>modern_autorelease_pool_release</Title>
            <Text>void
modern_autorelease_pool_release
(struct modern_error_handler *error_handler,
 modern_autorelease_pool *pool);</Text>
        </Document>
        <Document ID="194">
            <Title>modern_node_make_apply</Title>
            <Text>modern *
modern_node_make_apply
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 modern *left,
 modern *right);</Text>
        </Document>
        <Document ID="164">
            <Title>modern_node_make_float128</Title>
            <Text>modern *
modern_node_make_float128
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 long double value);</Text>
        </Document>
        <Document ID="134">
            <Title>modern_node_get_nat8</Title>
            <Text>uint8_t
modern_node_get_nat8
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="260">
            <Title>Semantics</Title>
            <Text>In Modern Data, the fundamental in-memory datatype is the “modern node”, which is a representation of, loosely, either a value or a type.  If we wish to specify further, we may occasionally refer to a “modern type” or “modern value”, but these concepts do not map to actual host-language datatypes; only “modern node” does.

The operations on a modern node are serialization and deserialization.  Serialization is performed on a stream of modern nodes in some “modern context”, and produces a stream of bytes.  Deserialization is performed on a stream of bytes in some modern context, and produces a stream of modern nodes.

Although simple applications which merely wish to exchange and act on data need never use anything but the default context, it is nonetheless a concept worth understanding.  The context is internally a hash table of modern types (and occasionally modern values).  The hash key is determined in a way that captures the notion of type equality, by placing the modern node in a canonical form and computing a hash function of that.  Any modern node which is in the hash table is “in scope” in that context.

Importantly, a modern type must be in scope in the given context before a value of that type can be serialized or deserialized. The high-level “node-based” portion of the library will check whether a value’s type is in context when serializing, and emit additional instructions which bring it into context if it is not, mutating the context object which it is passed to make note of the fact.  Similarly, when deserializing, if a value’s type is not in context, an error is produced and processing halts.  (To avoid security holes caused by different implementations responding to errors in different ways, processing is specified to always halt immediately upon the first error encountered.)

The low-level “stream-based” portion of the library does no such checking, as it tracks very little internal state, leaving that task to the client code.  The client code is thus responsible for ensuring that types are in context before they are used, both when serializing and when deserializing.

Cyclic structures, both at the type level and at the value level, can be created with either of two mechanisms: lambda expressions, and inductive families.  The details of how this is done are left to a later chapter; it is enough to know that which mechanism is chosen and the details of how it is used are not part of a modern node's identity; that is, they are all canonicalized to the same form.  As with the scope issue, the node-based portion of the library hides the issue of flattening cyclic structures from the client code, while the stream-based portion exposes it and places the burden on the client.

Note also that the mechanisms of lambda expressions and inductive values are also both available in the node-based way of working; they are never introduced automatically, but are honored when they are introduced manually.  The reason for this half-exposure is to ease construction of cyclic types, as detailed below.

The reader may be confused at this juncture: In other systems, lambda expressions are typically applicable only to values, while inductive families are typically applicable only to types.  In Modern Data, both mechanisms are applicable to both types and values.  This is not actually a necessary consequence of the ability to use types and values interchangeably in other situations, but it is certainly consistent with that design and makes more sense in that light.

Although many functional languages are additionally "purely functional", meaning that their variables are immutable, Modern Data values (but not types) can be mutated in memory in some languages.  This is to make it easier to create cyclic structures, which could not otherwise be done in languages without recursive binding.  The semantics of mutation are that all references to the old node become references to the new node.

The reason for disallowing mutation of nodes which are types is that it would not be possible in general to update preexisting values of that type to conform to the new definition automatically.  One solution which may come to mind is giving type nodes copy-on-write semantics, but this would necessitate large amounts of redundant copying in the case of making changes at several locations within a cyclically-structured type.  So, the burden of breaking cycles in types is placed on the client code.

Of course, it is expected that sets of types for some particular purpose will be constructed in most situations not through imperative code but through the use of an interactive editor having Modern Data as its native format.  The ease with which what would be called a schema in other systems can be serialized and deserialized obviates the need to construct one by hand, most of the time.  As such, the details of cycle-breaking should seldom be an issue.</Text>
        </Document>
        <Document ID="104">
            <Title>modern_autorelease_pool_get_allocator</Title>
            <Text>struct modern_allocator *
modern_autorelease_pool_get_allocator
(struct modern_error_handler *error_handler,
 modern_autorelease_pool *pool);</Text>
        </Document>
        <Document ID="230">
            <Title>modern_output_stream_memory_allocating_result</Title>
            <Text>uint8_t *
modern_output_stream_memory_allocating_result
(void *stream_state,
 size_t *length)</Text>
        </Document>
        <Document ID="195">
            <Title>modern_node_make_type_index</Title>
            <Text>modern *
modern_node_make_type_index
(struct modern_error_handler *error_handler,
 uint64_t index);</Text>
        </Document>
        <Document ID="200">
            <Title>modern_node_set_int16</Title>
            <Text>void
modern_node_set_int16
(struct modern_error_handler *error_handler,
 modern *node,
 int16_t value);</Text>
        </Document>
        <Document ID="165">
            <Title>modern_node_make_utf8</Title>
            <Text>modern *
modern_node_make_utf8
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint8_t *data);</Text>
        </Document>
        <Document ID="135">
            <Title>modern_node_get_nat16</Title>
            <Text>uint16_t
modern_node_get_nat16
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="261">
            <Title>modern_node_make_sigma_type</Title>
            <Text>modern *
modern_node_make_sigma_type
(struct modern_error_handler *error_handler,
 modern *field_type, modern *successor);</Text>
        </Document>
        <Document ID="105">
            <Title>modern_retain</Title>
            <Text>void
modern_retain
(struct modern_error_handler *error_handler,
 void *retainable);</Text>
        </Document>
        <Document ID="231">
            <Title>modern_output_stream_file</Title>
            <Text>void *
modern_output_stream_file
(modern_autorelease_pool *pool,
 FILE *file);</Text>
        </Document>
        <Document ID="196">
            <Title>modern_node_make_type_family</Title>
            <Text>modern *
modern_node_make_type_family
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint64_t n_items,
 modern **types);</Text>
        </Document>
        <Document ID="201">
            <Title>modern_node_set_int32</Title>
            <Text>void
modern_node_set_int32
(struct modern_error_handler *error_handler,
 modern *node,
 int32_t value);</Text>
        </Document>
        <Document ID="166">
            <Title>modern_node_make_blob</Title>
            <Text>modern *
modern_node_make_blob
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint8_t *data,
 size_t bytes);</Text>
        </Document>
        <Document ID="136">
            <Title>modern_node_get_nat32</Title>
            <Text>uint32_t
modern_node_get_nat32
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="262">
            <Title>modern_node_make_sigma</Title>
            <Text>modern *
modern_node_make_sigma
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 modern *type,
 modern *field_value,
 modern *successor_value);</Text>
        </Document>
        <Document ID="106">
            <Title>modern_release</Title>
            <Text>void
modern_release
(struct modern_error_handler *error_handler,
 void *retainable);</Text>
        </Document>
        <Document ID="232">
            <Title>modern_output_stream_fd</Title>
            <Text>void *
modern_output_stream_fd
(modern_autorelease_pool *pool,
 int fd);</Text>
        </Document>
        <Document ID="197">
            <Title>Mutation</Title>
        </Document>
        <Document ID="202">
            <Title>modern_node_set_int64</Title>
            <Text>void
modern_node_set_int64
(struct modern_error_handler *error_handler,
 modern *node,
 int64_t value);</Text>
        </Document>
        <Document ID="167">
            <Title>modern_node_make_array</Title>
            <Text>modern *
modern_node_make_array
(uint64_t n_items,
 modern **values);</Text>
        </Document>
        <Document ID="137">
            <Title>modern_node_get_nat64</Title>
            <Text>uint64_t
modern_node_get_nat64
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="263">
            <Title>modern_node_get_universe_type_level</Title>
            <Text>uint64_t
modern_node_get_universe_type_level
(struct modern_error_handler *error_handler,
 modern *value_in);</Text>
        </Document>
        <Document ID="107">
            <Title>modern_autorelease</Title>
            <Text>void
modern_autorelease
(struct modern_error_handler *error_handler,
 modern_autorelease_pool *pool,
 void *retainable);</Text>
        </Document>
        <Document ID="233">
            <Title>modern_output_stream_vfile</Title>
            <Text>void *
modern_output_stream_vfile
(modern_autorelease_pool *pool,
 struct modern_vfile *vfile,
 void *vfile_state);</Text>
        </Document>
        <Document ID="198">
            <Title>Values</Title>
        </Document>
        <Document ID="203">
            <Title>modern_node_set_nat8</Title>
            <Text>void
modern_node_set_nat8
(struct modern_error_handler *error_handler,
 modern *node,
 uint8_t value);</Text>
        </Document>
        <Document ID="168">
            <Title>modern_node_make_union</Title>
            <Text>modern *
modern_node_make_union
(modern *type,
 struct modern_hash *field,
 modern *value);</Text>
        </Document>
        <Document ID="138">
            <Title>modern_node_get_float32</Title>
            <Text>float
modern_node_get_float32
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="264">
            <Title>Library instances</Title>
        </Document>
        <Document ID="108">
            <Title>Contexts</Title>
        </Document>
        <Document ID="234">
            <Title>Hashing</Title>
        </Document>
        <Document ID="199">
            <Title>modern_node_set_int8</Title>
            <Text>void
modern_node_set_int8
(struct modern_error_handler *error_handler,
 modern *node,
 int8_t value);</Text>
        </Document>
        <Document ID="204">
            <Title>modern_node_set_nat16</Title>
            <Text>void
modern_node_set_nat16
(struct modern_error_handler *error_handler,
 modern *node,
 uint16_t value);</Text>
        </Document>
        <Document ID="169">
            <Title>modern_node_make_structure</Title>
            <Text>modern *
modern_node_make_structure
(modern *type,
 uint64_t n_items,
 struct modern_hash **fields,
 modern **values);</Text>
        </Document>
        <Document ID="139">
            <Title>modern_node_get_float64</Title>
            <Text>double
modern_node_get_float64
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="265">
            <Title>modern_library_initialize</Title>
            <Text>modern_library *
modern_library_initalize
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator);</Text>
        </Document>
        <Document ID="109">
            <Title>modern_make_initial_context</Title>
            <Text>modern_context *
modern_make_initial_context
();</Text>
        </Document>
        <Document ID="235">
            <Title>modern_compute_hash</Title>
            <Text>void
modern_compute_hash
(uint8_t *data,
 size_t length,
 struct modern_hash *out);</Text>
        </Document>
        <Document ID="205">
            <Title>modern_node_set_nat32</Title>
            <Text>void
modern_node_set_nat32
(struct modern_error_handler *error_handler,
 modern *node,
 uint32_t value);</Text>
        </Document>
        <Document ID="266">
            <Title>modern_library_get_error_handler</Title>
            <Text>struct modern_error_handler *
modern_library_get_error_handler
(modern_library *library);</Text>
        </Document>
        <Document ID="236">
            <Title>modern_compute_child_hash</Title>
            <Text>void
modern_compute_child_hash
(struct modern_hash *parent,
 uint8_t *data,
 size_t length,
 struct modern_hash *out);</Text>
        </Document>
        <Document ID="206">
            <Title>modern_node_set_nat64</Title>
            <Text>void
modern_node_set_nat64
(struct modern_error_handler *error_handler,
 modern *node,
 uint64_t value);</Text>
        </Document>
        <Document ID="3">
            <Title>Introduction</Title>
            <Text>Modern Data is a compact, binary, dependently-typed, self-describing data format for object graphs, and also a library.

A self-describing data format is a format like XML, JSON, or Common Lisp’s s-expressions, which can be processed at a superficial level without knowledge of the specific type of data it contains.  The typical purpose of such formats is interchange across diverse software tools; for example, many tools for working with databases can produce output or accept input in XML.  They can also be useful intermediate representations for transformations on data structures, as with XSLT.  They can even be used for network protocols, as with XMPP/Jabber.  Modern Data is at least as suitable for these tasks as any existing format.

Unlike the above-mentioned alternatives, Modern Data is exclusively a binary format, not a textual one.  This is because textual formats can be written directly by humans, who can make mistakes, which software tools must then cope with, which can be quite difficult and lead to unexpected behavior and, when processing is done inconsistently by different implementations, even to security holes.  A binary format can be written only by the use of assistive software which understands the format, so it is not subject to this problem.

Although not the primary motivation for the choice, a benefit of being a binary format is a certain compactness.  Care has been taken to ensure that the format can in principle be used by database engines and the like as a native format - perhaps slightly larger than non-self-describing forms, but not enormously so as a textual format would be, and without needing a parse phase to perform simple actions such as scanning through it.  Specifically, the format does not use offset-based pointers, so it is suitable for embedding in other formats that do their own space allocation.

It would be difficult to discuss the specifics of Modern Data with no notation for it at all; therefore, there are in fact textual notations for it.  But parsers for these notations are not part of the library - only generators.  This should hopefully remove the temptation to use them for any purpose but documentation and standardization.

The above benefits are substantial, but the most distinctive attribute of Modern Data compared to existing formats is that it is dependently typed.  In a formal sense, this means that types and values are intermixable.  Thus the schema for a Modern Data document is itself potentially a Modern Data document, using a type as a value.  Furthermore, bounds-checked arrays, dimensioned quantities, and the like can all be expressed through values used within types, in ways that will be familiar to programmers who have used theorem-proving languages such as Agda, Coq, Epigram, and Idris.

Another benefit that is a prerequisite of dependent typing but will not be obvious to programmers who are unfamiliar with Hindley-Milner-style type systems is that types are parametric; this means, for example, that it is possible to write the incomplete type “balanced binary tree containing leaf nodes of some particular type”, without specifying the content type at the time that the tree type is defined; the type parameter can be filled in to instantiate that tree for any desired content type, thus obtaining a complete type, which can actually be instantiated.  This will be familiar to Haskell and ML programmers; it is also reminiscent of C++ and Java templates, but the meaning of it has been more rigorously formalized.

Furthermore, code can be written using the library which operates on a parametric type such as our binary tree example, generically to its specific parameters - thus code can be written which rebalances a tree after an update, without knowing the type of the contents.  The library is written such that these operations can be efficiently performed without the need to convert Modern Data to a separate in-memory representation.

Modern Data, unlike other self-describing formats, is capable of representing an arbitrary object graph - not merely one that has obvious linear structure.  This is accomplished without pointers or globally-scoped identifiers of any kind, and therefore does not impede use embedded within other formats, as mentioned above.  The benefit is that arbitrary data structures can be represented directly, including ones which would have cyclic pointers in their traditional in-memory representations.

The Modern Data base library is written in C.  Not because it’s more suitable for the task than other languages would be - it’s not.  Rather, functional languages tend to have runtime systems (largely consisting of garbage collectors) which make the scenario of deploying a library to be linked against from other languages more difficult.  Obviously there will be bindings written in functional languages, as functional programming is the paradigm best equipped to take advantage of Modern Data’s features, but the library will always be in a system language, so that it can easily be linked against from as many other languages as possible.  Care has been taken to play nicely with foreign-function interfaces, which cannot always use the full capabilities of the C ABI.

Please, come on in - and enjoy the type system!</Text>
        </Document>
        <Document ID="267">
            <Title>modern_library_get_allocator</Title>
            <Text>struct modern_allocator *
modern_library_get_allocator
(modern_library *library);</Text>
        </Document>
        <Document ID="5">
            <Title>Scrawlings</Title>
            <Text>For C, everything is effectively like Data.Dynamic.  For Haskell there will be a GADT and an existential.

Node types “lambda”, “apply”, “index” (as in De Bruijn), and “family” (as in inductive type family).

Things like void (*modern_stream_type_definition_int8)(void *processor, void *context) are callbacks invoked when type IDs are read.  All the functions in that struct are callbacks that are invoked on things that happen during streaming parsing.  The API for streaming generation is the same - except the client code is the consumer of the struct and the caller of these functions, rather than the provider of them.  Note that using the streaming API it is possible to construct invalid output; if this is a concern the object-model API should be used instead.

To make things with cycles, what happens behind the scenes is…  Well, it’s not behind the scenes when you’re doing streaming mode, but in object-model mode, it uses lambdas and applies.  The “prelude” has the S and K combinators already defined, which isn’t strictly necessary because you could define them yourself, but it’s a convenience.

The Lisp-like syntax is the debug format, for use in, say, standards documents that describe APIs in which the units of data interchange are values in Modern Data.

So a point I’m not totally sure on is that I think I just need one version of lambda and one version of apply - as opposed to one of each for values and another of each for types.

Recursive types, such as the simple tree type (in Haskell notation) data Tree = Internal (Tree a) (Tree a) | Leaf a, are defined as cyclic structures.  This avoids the need to refer to anything by name, ever, although the system does in fact support names.

This is on the type level but it’s dependent, so the machinery is the same for types as for values.

I am unclear on whether to implement the set hierarchy, or type-in-type.  I know that I want to call it “universe”, because “set” is a poor name suggestive of set theory rather than type theory.  If I do use the set hierarchy, I expect to have a finite limit, probably 64 bits, on how high one can go.  This is not really any more of a wart than a limit placed on how large an array can be.

With both lambdas and applies present, in principle full computation is possible.

Some parts of this are simply matters of good C practice than of dependent types.  For example, the use of vfile structures for when you want to read a Modern Data value that’s in a zipfile.

You can basically use Modern Data for anything you presently do with XML or HTML or JSON or whatnot, except you can also communicate types across it.  So schemas are built in.  XML schema description is a bugbear that they’ve had a lot of failed attempts at.  You can “teach” the other end how to at least process your thing, even if it doesn’t know your types in advance, by sending a type-as-data across the wire.  You can write helper utilities that only understand some of the types and not the rest, to make “map” and other higher-order functions.

The original motivator was because I hate using text as the format for shell commands.

There should be all sorts of applications.  I think it applies to the functional-database problem, too, even.

In principle you could write webpages in it.

You could implement a programming “language” in it.  The source code would be simply a data structure, instead of being text.  If you like text, you can treat the textual presentation as simply a formatting layer.

Once the basic library is working I’m going to make a generic graphical editor for this, for the Mac.

You can use it for network protocols, too; XMPP/Jabber is similar but using XML as the self-describing data format.

The type system exposes a lot of very low-level types.  I intend to build more higher-level types on top, but the goal at this stage is to provide all the primitives.  After that, I can play around and stuff.  I don’t plan for the higher-level types to be part of the “standard”, because that wouldn’t buy anything - they don’t need to be agreed upon in advance to use them, since the schema is expressible in the system itself.

For aggregate types, I originally broke it down to array (one-dimensional, nothing fancy with the indices; anything more complicated can be built on top); union, which assigns a name to each field it may contain, and exactly one of those fields is present in an actual value; structure, which also assigns a name to each field, but all the fields are present.  Structures, notably, did not have field orders; that is, two structure types with the same field names and types were equivalent regardless of the order the fields appeared in.  And the last aggregate type is “named”.  Notice that in array, union, and structure, the aggregate doesn’t have its own name, which makes anonymous ones possible.  The capability is separated out.

For text the type is UTF-8.  There are no types for other character sets or encodings, because that’s the right one 99% of the time.

There’s blob, too, so if you need to embed non-Modern data in some known format, you can just make a blob out of it.

However, the type system has been simplified now - instead of array, union, and structure, there’s just sigma.</Text>
        </Document>
        <Document ID="237">
            <Title>modern_get_initial_namespace_hash</Title>
            <Text>void
modern_get_initial_namespace_hash
(struct modern_hash *out);</Text>
        </Document>
        <Document ID="207">
            <Title>modern_node_set_float32</Title>
            <Text>void
modern_node_set_float32
(struct modern_error_handler *error_handler,
 modern *node,
 float value);</Text>
        </Document>
        <Document ID="6">
            <Title>C Library Reference</Title>
        </Document>
        <Document ID="7">
            <Title>The "modern" type</Title>
            <Text>typedef void modern;

The “modern” type is a polymorphic node for object-oriented access to both types and values.  Because it is not limited to values, it is not called “modern_data”; it is simply called “modern” and the library user is encouraged to think of it as its own thing.

Note that this is true in all the versions of the library for non-functional languages, but in languages which support generalized algebraic datatypes, the situation is more complicated; see for example the Haskell version.</Text>
        </Document>
        <Document ID="8">
            <Title>Modern contexts</Title>
            <Text>typedef void modern_context;</Text>
        </Document>
        <Document ID="238">
            <Title>Predefined Virtual Files</Title>
        </Document>
        <Document ID="208">
            <Title>modern_node_set_float64</Title>
            <Text>void
modern_node_set_float64
(struct modern_error_handler *error_handler,
 modern *node,
 double value);</Text>
        </Document>
        <Document ID="9">
            <Title>Modern autorelease pools</Title>
            <Text>typedef void modern_autorelease_pool;</Text>
        </Document>
        <Document ID="269">
            <Title>modern_library_finalize</Title>
            <Text>void
modern_library_finalize
(modern_library *library);
</Text>
        </Document>
        <Document ID="239">
            <Title>modern_get_memory_buffer_vfile</Title>
            <Text>struct modern_vfile *
modern_get_memory_buffer_vfile
();</Text>
        </Document>
        <Document ID="209">
            <Title>modern_node_set_float128</Title>
            <Text>void
modern_node_set_float128
(struct modern_error_handler *error_handler,
 modern *node,
 long double value);</Text>
        </Document>
        <Document ID="180">
            <Title>modern_node_get_nat16_type</Title>
            <Text>modern *
modern_node_get_nat16_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="150">
            <Title>modern_node_get_lambda_content</Title>
            <Text>modern *
modern_node_get_lambda_content
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="120">
            <Title>modern_serialize_memory_buffer</Title>
            <Text>void
modern_serialize_memory_buffer
(modern *value,
 modern_context *context,
 uint8_t *buffer,
 size_t *length);</Text>
        </Document>
        <Document ID="181">
            <Title>modern_node_get_nat32_type</Title>
            <Text>modern *
modern_node_get_nat32_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="151">
            <Title>modern_node_get_apply_left</Title>
            <Text>modern *
modern_node_get_apply_left
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="121">
            <Title>modern_serialize_memory_allocating</Title>
            <Text>uint8_t *
modern_serialize_memory_allocating
(modern *value,
 modern_context *context,
 struct modern_allocator *allocator,
 size_t *length);</Text>
        </Document>
        <Document ID="182">
            <Title>modern_node_get_nat64_type</Title>
            <Text>modern *
modern_node_get_nat64_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="152">
            <Title>modern_node_get_apply_right</Title>
            <Text>modern *
modern_node_get_apply_right
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="122">
            <Title>modern_serialize_file</Title>
            <Text>void
modern_serialize_file
(modern *value,
 modern_context *context,
 FILE *file);</Text>
        </Document>
        <Document ID="183">
            <Title>modern_node_get_float32_type</Title>
            <Text>modern *
modern_node_get_float32_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="153">
            <Title>Construction</Title>
        </Document>
        <Document ID="123">
            <Title>modern_serialize_fd</Title>
            <Text>void
modern_serialize_fd
(modern *value,
 modern_context *context,
 int fd);</Text>
        </Document>
        <Document ID="184">
            <Title>modern_node_get_float64_type</Title>
            <Text>modern *
modern_node_get_float64_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="154">
            <Title>modern_node_make_int8</Title>
            <Text>modern *
modern_node_make_int8
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 int8_t value);</Text>
        </Document>
        <Document ID="124">
            <Title>modern_serialize_vfile</Title>
            <Text>void
modern_serialize_vfile
(modern *value,
 modern_context *context,
 struct modern_vfile *vfile,
 void *vfile_state);</Text>
        </Document>
        <Document ID="250">
            <Title>modern_allocator_realloc</Title>
            <Text>void *
(*modern_allocator_realloc)
(void *memory, size_t size);</Text>
        </Document>
        <Document ID="220">
            <Title>modern_input_stream_vfile</Title>
            <Text>void *
modern_input_stream_vfile
(modern_autorelease_pool *pool,
 struct modern_stream *stream,
 struct modern_vfile *vfile,
 void *vfile_state);</Text>
        </Document>
        <Document ID="185">
            <Title>modern_node_get_float128_type</Title>
            <Text>modern *
modern_node_get_float128_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="155">
            <Title>modern_node_make_int16</Title>
            <Text>modern *
modern_node_make_int16
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 int16_t value);</Text>
        </Document>
        <Document ID="125">
            <Title>modern_serialize_output_stream</Title>
            <Text>modern *
modern_serialize_output_stream
(modern *value,
 modern_context *context,
 struct modern_stream *stream);</Text>
        </Document>
        <Document ID="251">
            <Title>pool</Title>
            <Text>modern_autorelease_pool *pool;</Text>
        </Document>
        <Document ID="221">
            <Title>Customization</Title>
        </Document>
        <Document ID="186">
            <Title>modern_node_get_utf8_type</Title>
            <Text>modern *
modern_node_get_utf8_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="156">
            <Title>modern_node_make_int32</Title>
            <Text>modern *
modern_node_make_int32
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 int32_t value);</Text>
        </Document>
        <Document ID="126">
            <Title>Node-based object model</Title>
        </Document>
        <Document ID="252">
            <Title>modern_processor_abort</Title>
            <Text>void
(*modern_processor_abort)
(void *processor_state);</Text>
        </Document>
        <Document ID="222">
            <Title>modern_input_stream_step</Title>
            <Text>void
modern_input_stream_step
(struct modern_stream *stream,
 void *processor_state,
 void **stream_state);</Text>
        </Document>
        <Document ID="187">
            <Title>modern_node_get_blob_type</Title>
            <Text>modern *
modern_node_get_blob_type
(struct modern_error_handler *error_handler);</Text>
        </Document>
        <Document ID="157">
            <Title>modern_node_make_int64</Title>
            <Text>modern *
modern_node_make_int64
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 int64_t value);</Text>
        </Document>
        <Document ID="127">
            <Title>Reading</Title>
        </Document>
        <Document ID="253">
            <Title>modern_processor_flush</Title>
            <Text>void (*modern_processor_flush)
  (void *processor_state);</Text>
        </Document>
        <Document ID="223">
            <Title>modern_input_stream_run</Title>
            <Text>void
modern_input_stream_run
(struct modern_stream *stream,
 void *processor_state,
 void **stream_state);</Text>
        </Document>
        <Document ID="188">
            <Title>modern_node_make_array_type</Title>
            <Text>modern *
modern_node_make_array_type
(modern *content_type);</Text>
        </Document>
        <Document ID="158">
            <Title>modern_node_make_nat8</Title>
            <Text>modern *
modern_node_make_nat8
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint8_t value);</Text>
        </Document>
        <Document ID="128">
            <Title>modern_node_get_node_type</Title>
            <Text>enum modern_node_type
modern_node_get_node_type
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="254">
            <Title>Predefined Hashes</Title>
        </Document>
        <Document ID="224">
            <Title>modern_input_stream_do_all</Title>
            <Text>void
modern_input_stream_do_all
(struct modern_stream *stream,
 void *processor_state);</Text>
        </Document>
        <Document ID="189">
            <Title>modern_node_make_union_type</Title>
            <Text>modern *
modern_node_make_union_type
(uint64_t n_items,
 struct modern_hash **fields,
 modern **types);</Text>
        </Document>
        <Document ID="159">
            <Title>modern_node_make_nat16</Title>
            <Text>modern *
modern_node_make_nat16
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 uint16_t value);</Text>
        </Document>
        <Document ID="129">
            <Title>modern_node_get_value_type</Title>
            <Text>modern *
modern_node_get_value_type
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="255">
            <Title>Untitled</Title>
        </Document>
        <Document ID="225">
            <Title>modern_input_stream_finalize</Title>
            <Text>void
modern_input_stream_finalize
(void *processor_state);</Text>
        </Document>
        <Document ID="256">
            <Title>modern_stream_nat16</Title>
            <Text>void
(*modern_stream_nat16)
(void *processor_state,
 void *stream_state,
 uint16_t value);</Text>
        </Document>
        <Document ID="226">
            <Title>General</Title>
        </Document>
        <Document ID="257">
            <Title>modern_stream_nat32</Title>
            <Text>void
(*modern_stream_nat32)
(void *processor_state,
 void *stream_state,
 uint32_t value);</Text>
        </Document>
        <Document ID="227">
            <Title>Streaming Output</Title>
        </Document>
        <Document ID="258">
            <Title>modern_stream_nat64</Title>
            <Text>void
(*modern_stream_nat64)
(void *processor_state,
 void *stream_state,
 uint64_t value);</Text>
        </Document>
        <Document ID="228">
            <Title>modern_output_stream_memory_buffer</Title>
            <Text>void *
modern_output_stream_memory_buffer
(modern_autorelease_pool *pool,
 uint8_t *buffer,
 size_t *length);</Text>
        </Document>
        <Document ID="259">
            <Title>modern_copy_context</Title>
            <Text>modern_context *
modern_copy_context
(modern_context *context);</Text>
        </Document>
        <Document ID="229">
            <Title>modern_output_stream_memory_allocating</Title>
            <Text>void *
modern_output_stream_memory_allocating
(modern_autorelease_pool *pool,
 size_t *length);</Text>
        </Document>
        <Document ID="10">
            <Title>Hashes</Title>
            <Text>struct modern_hash {
    uint64_t a;
    uint64_t b;
};</Text>
        </Document>
        <Document ID="11">
            <Title>Allocators</Title>
            <Text>struct modern_allocator {
    …
};</Text>
        </Document>
        <Document ID="12">
            <Title>Processors</Title>
            <Text>struct modern_processor {
    …
};</Text>
        </Document>
        <Document ID="13">
            <Title>Streams</Title>
            <Text>struct modern_stream {
    …
};</Text>
        </Document>
        <Document ID="14">
            <Title>modern_stream_initialize</Title>
            <Text>void *
(*modern_stream_initialize)
();</Text>
        </Document>
        <Document ID="20">
            <Title>modern_stream_type_definition_int16</Title>
            <Text>void
(*modern_stream_type_definition_int16)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="15">
            <Title>modern_stream_start</Title>
            <Text>void
(*modern_stream_start)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="21">
            <Title>modern_stream_type_definition_int32</Title>
            <Text>void
(*modern_stream_type_definition_int32)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="16">
            <Title>modern_stream_type_magic_number</Title>
            <Text>void
(*modern_stream_type_magic_number)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="22">
            <Title>modern_stream_type_definition_int64</Title>
            <Text>void
(*modern_stream_type_definition_int64)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="17">
            <Title>modern_stream_name_definition</Title>
            <Text>void
(*modern_stream_name_definition)
(void *processor_state,
 void *stream_state,
 uint8_t *data,
 size_t length);</Text>
        </Document>
        <Document ID="23">
            <Title>modern_stream_type_definition_nat8</Title>
            <Text>void
(*modern_stream_type_definition_nat8)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="18">
            <Title>modern_stream_type_definition_is_next</Title>
            <Text>void
(*modern_stream_type_definition_is_next)
(void *processor_state,
 void *stream_state,
 struct modern_hash *type);</Text>
        </Document>
        <Document ID="24">
            <Title>modern_stream_type_definition_nat16</Title>
            <Text>void
(*modern_stream_type_definition_nat16)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="19">
            <Title>modern_stream_type_definition_int8</Title>
            <Text>void
(*modern_stream_type_definition_int8)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="30">
            <Title>modern_stream_type_definition_utf8</Title>
            <Text>void
(*modern_stream_type_definition_utf8)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="170">
            <Title>modern_node_make_named_value</Title>
            <Text>modern *
modern_node_make_named_value
(struct modern_error_handler *error_handler,
 struct modern_allocator *allocator,
 modern *type,
 modern *value);</Text>
        </Document>
        <Document ID="140">
            <Title>modern_node_get_float128</Title>
            <Text>long double
modern_node_get_float128
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="25">
            <Title>modern_stream_type_definition_nat32</Title>
            <Text>void
(*modern_stream_type_definition_nat32)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="110">
            <Title>modern_get_in_context</Title>
            <Text>int
modern_get_in_context
(modern_context *context,
 modern *node);</Text>
        </Document>
        <Document ID="31">
            <Title>modern_stream_type_definition_blob</Title>
            <Text>void
(*modern_stream_type_definition_blob)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="26">
            <Title>modern_stream_type_definition_nat64</Title>
            <Text>void
(*modern_stream_type_definition_nat64)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="171">
            <Title>Types</Title>
        </Document>
        <Document ID="32">
            <Title>modern_stream_type_definition_function_is_next</Title>
            <Text>void
(*modern_stream_type_definition_function_is_next)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="141">
            <Title>modern_node_get_utf8_bytes</Title>
            <Text>size_t
modern_node_get_utf8_bytes
(struct modern_error_handler *error_handler,
 modern *value);</Text>
        </Document>
        <Document ID="27">
            <Title>modern_stream_type_definition_float32</Title>
            <Text>void
(*modern_stream_type_definition_float32)
(void *processor_state,
 void *stream_state);</Text>
        </Document>
        <Document ID="111">
            <Title>modern_add_to_context</Title>
            <Text>void
modern_add_to_context
(modern_context *context,
 modern *node);</Text>
        </Document>
        <Document ID="33">
            <Title>modern_stream_type_definition_sigma_is_next</Title>
            <Text>void
(*modern_stream_type_definition_sigma_is_next)
(void *processor_state,
 void *stream_state
 struct modern_hash *a,
 struct modern_hash *b);</Text>
        </Document>
    </Documents>
</SearchIndexes>