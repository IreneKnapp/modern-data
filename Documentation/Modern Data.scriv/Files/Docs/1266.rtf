{\rtf1\ansi\ansicpg1252\cocoartf1187
{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li11\fi-1\pardirnatural

\f0\fs24 \cf0 Virtual files, often abbreviated to vfiles herein, are a type of object which represents an abstract stream of bytes which can be read from and/or written to.  They have a transparent part, which is a structure containing pointers to callback functions, and an opaque part, which is represented as a void pointer.  In typical usage, client code will obtain a virtual file from the system appropriate to the task it wishes to perform, then pass this virtual file into the .  It is also possible for client code to construct its own virtual file and have the system use it, for special-purpose cases.  For example, a Modern Data document might be embedded in a container format such as zip or tar; a special-purpose virtual file could enable deserializing it in-place, without first unpacking the container.\
\
There are just two callbacks in the vfile structure.  To obtain data, use modern_vfile_read().  To produce it, use modern_vfile_write().  A vfile which is only to be used for input need only implement the read function, and similarly for output.\
\
Unlike some of the other object types in Modern Data, such as the node and stream abstractions, the initialization and finaliziation methods are not part of the callback structure.  This is because different vfile types require different parameters upon initialization.  It is the responsibility of the code providing a vfile to also provide a mechanism to initialize and finalize it.  For example, modern_vfile_memory_buffer_initialize() is the function to initialize one particular kind of vfile, which is backed by a buffer of memory managed by the client.  Its parameters are different from those of modern_vfile_stdio_initialize(), which is specific to a vfile backed by a file pointer created by the standard C library.}