{\rtf1\ansi\ansicpg1252\cocoartf1187
{\fonttbl\f0\fnil\fcharset0 Cochin;}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li11\fi-1\pardirnatural

\f0\fs24 \cf0 Importantly, a modern type must be in scope in the given context before a value of that type can be serialized or deserialized. The high-level \'93node-based\'94 portion of the library will check whether a value\'92s type is in context when serializing, and emit additional instructions which bring it into context if it is not, mutating the context object which it is passed to make note of the fact.  Similarly, when deserializing, if a value\'92s type is not in context, an error is produced and processing halts.  (To avoid security holes caused by different implementations responding to errors in different ways, processing is specified to always halt immediately upon the first error encountered.)\
\
The low-level \'93stream-based\'94 portion of the library does no such checking, as it tracks very little internal state, leaving that task to the client code.  The client code is thus responsible for ensuring that types are in context before they are used, both when serializing and when deserializing.\
\
Cyclic structures, both at the type level and at the value level, can be created with inductive families and recursive lets - these two mechanisms are similar to each other, with the one being for types and the other for values.  The details of how this is done are left to a later chapter.  It is enough to know that the details of how these mechanisms are used do in fact become part of a modern node\'92s identity.  That is, they affect how types are canonicalized, which means that you have a different type if you insert the inductive family into the structure at a different place.  Canonicalization does not apply to values (except for values which are part of types), so the fact that the details of a recursive let also affect the node\'92s identity is not important in most situations.\
\
As with the scope issue, the node-based portion of the library hides the issue of flattening cyclic structures from the client code, while the stream-based portion exposes it and places the burden on the client.  However, this hiding cannot be complete, so it is important to be aware of its semantics.\
\
Cycles will be automatically broken by introducing the appropriate constructs at the time that they need to be serialized, if they have not already been; cycle-breaking can also be introduced manually.  Thus users can build up cyclic structures through mutation and expect serialization and deserialization of them to \'93just work\'94, or they can use inductive families and recursive lets directly, and that will also work.\
\
When inspecting a node-based structure in memory, there are two versions of each library call which returns a related node.  The version for general use processes indirect references transparently, following them repeatedly until arriving at a node which is not an indirection.  The version for special-purpose use does no such processing, instead returning the indirection node itself.  This is analogous to the way that Unix-like operating systems handle symbolic links in their filesystems.\
\
It\'92s worth noting in passing that it is bad style but technically possible in some situations to use an inductive family in defining values, and to use a recursive let in defining types.  This is not actually a necessary consequence of the ability to use types and values interchangeably in other situations, but it is certainly consistent with that design and makes more sense in that light.\
\
Although many functional languages are additionally "purely functional", meaning that their variables are immutable, nodes can be mutated in memory in some languages.  This is to make it easier to create cyclic structures, which could not otherwise be done in languages without recursive binding.  The semantics of mutation are that all references to the old node become references to the new node.  Mutation is possible on all nodes, with the provision that nodes being modified have never been in scope in any context.  In other words, once a node has become part of a schema of types and and thus potentially has extant nodes which are values of it, it can no longer be modified.  This is, of course, to avoid the scenario of a value node being inconsistent in structure with the type node that corresponds to it.  Naturally, it is always possible to construct a copy of a node and modify the copy.\
\
Of course, it is expected that sets of types for some particular purpose will be constructed in most situations not through imperative code but through the use of an interactive editor having Modern Data as its native format.  The ease with which what would be called a schema in other systems can be serialized and deserialized obviates the need to construct one by hand, most of the time.  As such, the details discussed above should seldom be an issue.}